Rekayasa perangkat lunak adalah aplikasi sistematis teknik pendekatan untuk pengembangan perangkat lunak.
Rekayasa perangkat lunak adalah sub-bidang langsung dari teknik dan memiliki tumpang tindih dengan ilmu komputer dan ilmu manajemen.
Hal ini juga dianggap sebagai bagian dari rekayasa sistem secara keseluruhan.

Sejarah rekayasa perangkat lunak
Komputer digital pertama kali muncul di awal 1940-an,petunjuk membuat mereka beroperasikan kabel ke dalam mesin.
Praktisi cepat menyadari bahwa desain ini tidak fleksibel dan datang dengan "arsitektur program yang tersimpan" atau arsitektur von Neumann.
Dengan demikian pembagian antara "hardware" dan "software" dimulai dengan abstraksi yang digunakan untuk menangani kompleksitas komputasi.

Bahasa pemrograman mulai muncul di awal 1950-an.
Software engineering
Bahasa utama seperti Fortran, ALGOL, dan COBOL yang dirilis pada akhir 1950-an untuk menangani masalah ilmiah, algoritmik, dan bisnis masing-masing.
David Parnas memperkenalkan konsep kunci modularitas dan penyembunyian informasi pada tahun 1972 untuk membantu kompleksitas sistem perangkat lunak yang semakin meningkat.

definisi
definisi penting dari rekayasa perangkat lunak meliputi:
"Aplikasi sistematis pengetahuan ilmiah dan teknologi, metode, dan pengalaman untuk desain, implementasi, pengujian, dan dokumentasi perangkat lunak" -The Biro Statistik Tenaga Kerja IEEE-Systems dan rekayasa perangkat lunak - Kosakata
"Penerapan sistematis, disiplin, pendekatan kuantitatif untuk pengembangan, operasi, dan pemeliharaan perangkat lunak" -IEEE Standar Istilah Rekayasa Perangkat Lunak Terminologi
"Disiplin teknik yang berkaitan dengan semua aspek produksi perangkat lunak" -Ian Sommerville 
"Pembentukan dan penggunaan prinsip-prinsip rekayasa suara untuk mendapatkan software yang handal dan bekerja secara efisien pada mesin nyata ekonomi" -Fritz Bauer [20]
"Cabang ilmu komputer yang berkaitan dengan desain, implementasi, dan pemeliharaan program komputer yang rumit" -Merriam-Webster 
Istilah ini juga telah digunakan kurang formal:

Desain perangkat lunak
Software desain adalah tentang proses mendefinisikan arsitektur, komponen, antarmuka, dan karakteristik lain dari sistem atau komponen. Ini juga disebut arsitektur Software.

Pengembangan perangkat lunak
pengembangan perangkat lunak, kegiatan utama pembangunan software:adalah kombinasi dari pemrograman (alias coding), verifikasi, pengujian perangkat lunak, dan debugging. Sebuah proses pengembangan perangkat lunak:adalah definisi, implementasi, penilaian, pengukuran, manajemen, perubahan, dan perbaikan dari proses siklus hidup perangkat lunak itu sendiri.
Ini menggunakan Software manajemen konfigurasi yang sekitar sistematis mengendalikan perubahan konfigurasi, dan memelihara integritas dan keterlusuran konfigurasi dan kode sepanjang siklus hidup sistem. proses modern menggunakan software versi.

software pengujian
pengujian perangkat lunak:adalah empiris, penyelidikan teknis yang dilakukan untuk memberikan stakeholder dengan informasi kualitas produk atau jasa yang diuji, dengan berbagai pendekatan seperti pengujian unit dan pengujian integrasi. Ini merupakan salah satu aspek dari kualitas perangkat lunak.

pemeliharaan perangkat lunak
Pemeliharaan perangkat lunak:mengacu pada kegiatan yang diperlukan untuk memberi dukungan biaya-efektif setelah pengiriman produk perangkat lunak.

pendidikan
Pengetahuan tentang pemrograman komputer merupakan prasyarat untuk menjadi insinyur perangkat lunak. Pada tahun 2004 IEEE Computer Society menghasilkan SWEBOK, yang telah diterbitkan sebagai ISO / IEC Laporan Teknis 1979:.
2004, menggambarkan tubuh pengetahuan yang mereka sarankan harus dikuasai oleh seorang insinyur perangkat lunak lulus dengan empat tahun pengalaman Banyak insinyur perangkat lunak memasuki profesi dengan mendapatkan gelar universitas atau pelatihan di sekolah kejuruan.
Salah satu kurikulum internasional standar untuk gelar rekayasa perangkat lunak sarjana didefinisikan oleh Task Force Bersama Computing Kurikulum dari IEEE Computer Society dan Association for Computing Machinery, dan diperbarui pada tahun 2014.
Sejumlah universitas memiliki program gelar Rekayasa Perangkat Lunak; pada 2010, ada 244 Kampus Bachelor of Software program Teknik, 70 program Online, 230 program Master-tingkat, 41 program Doktor tingkat, dan 69 program Sertifikat tingkat di Amerika Serikat.
Selain pendidikan universitas, banyak perusahaan mensponsori magang bagi siswa yang ingin mengejar karir di bidang teknologi informasi. magang ini dapat memperkenalkan siswa untuk tugas-tugas dunia nyata menarik bahwa insinyur perangkat lunak khas temui setiap hari. pengalaman serupa dapat diperoleh melalui dinas militer dalam rekayasa perangkat lunak.

Software configuration management
Dalam rekayasa perangkat lunak, manajemen konfigurasi perangkat lunak (SCM atau S / W CM) adalah tugas pelacakan dan mengendalikan perubahan dalam perangkat lunak, bagian dari bidang yang lebih besar lintas disiplin dari manajemen konfigurasi.
praktek SCM meliputi kontrol revisi dan pembentukan baseline. Jika ada yang salah, SCM dapat menentukan apa yang berubah dan yang berubah itu. Jika konfigurasi bekerja dengan baik, SCM dapat menentukan bagaimana untuk mereplikasi di banyak host.
Akronim "SCM" juga diperluas sebagai proses manajemen konfigurasi sumber dan perubahan perangkat lunak dan manajemen konfigurasi.Namun, "konfigurasi" umumnya dipahami untuk perubahan tutupan biasanya dibuat oleh administrator sistem.

Identifikasi konfigurasi - Mengidentifikasi konfigurasi, item konfigurasi dan baseline.
kontrol konfigurasi - Menerapkan proses perubahan dikendalikan. Hal ini dicapai dengan mendirikan papan kontrol perubahan yang fungsi nya adalah untuk menyetujui atau menolak semua permintaan perubahan yang dikirim terhadap dasar apapun.
akuntansi konfigurasi Status - Pencatatan dan pelaporan semua informasi yang diperlukan tentang status proses pembangunan.
Konfigurasi audit - Memastikan bahwa konfigurasi mengandung semua bagian mereka dimaksudkan dan suara sehubungan dengan dokumen menentukan mereka, termasuk persyaratan, spesifikasi arsitektur dan manual pengguna.
manajemen membangun - Mengelola proses dan alat-alat yang digunakan untuk membangun.
Proses manajemen - Memastikan kepatuhan terhadap proses pengembangan organisasi.
manajemen lingkungan - Mengelola perangkat lunak dan perangkat keras yang tuan sistem.
Teamwork - Memfasilitasi interaksi tim yang terkait dengan proses.
Cacat pelacakan - Memastikan setiap cacat memiliki traceability kembali ke sumber.
Dengan diperkenalkannya komputasi awan keperluan alat SCM telah menjadi digabung dalam beberapa kasus. Alat SCM sendiri telah menjadi peralatan virtual yang dapat dipakai sebagai mesin virtual dan disimpan dengan negara dan versi. Alat dapat model dan mengelola sumber daya berbasis cloud virtual, termasuk peralatan virtual, unit penyimpanan, dan bundel software. Peran dan tanggung jawab dari pelaku telah menjadi bergabung juga dengan pengembang sekarang mampu server secara dinamis instantiate virtual dan sumber daya terkait. [4]

Sejarah
Sejarah (SCM) dalam komputasi dapat ditelusuri kembali pada awal tahun 1950-an, ketika CM (Manajemen Konfigurasi), awalnya pengembangan hardware dan pengendalian produksi, sedang diterapkan pengembangan perangkat lunak. software awal memiliki jejak fisik, seperti kartu, kaset, dan media lainnya. Manajemen konfigurasi perangkat lunak pertama adalah operasi manual.
Dengan kemajuan dalam bahasa dan kompleksitas, rekayasa perangkat lunak, yang melibatkan manajemen konfigurasi dan metode lain, menjadi perhatian utama karena masalah seperti jadwal, anggaran, dan kualitas. pelajaran praktis, selama bertahun-tahun, telah menyebabkan definisi, dan pembentukan, prosedur dan alat-alat. Akhirnya, alat menjadi sistem untuk mengelola perubahan perangkat lunak.
praktik industri-lebar yang ditawarkan sebagai solusi, baik secara terbuka atau kepemilikan (seperti Revisi Control System). Dengan meningkatnya penggunaan komputer, sistem muncul yang ditangani lingkup yang lebih luas, termasuk manajemen persyaratan, alternatif desain, kontrol kualitas, dan banyak lagi; alat kemudian mengikuti pedoman organisasi, seperti Capability Maturity Model dari Engineering Institute Software.

kontrol versi
"Sistem kontrol revisi". Untuk implementasi perangkat lunak tertentu,.
Sebuah komponen dari manajemen konfigurasi perangkat lunak, kontrol versi, juga dikenal sebagai kontrol revisi atau kontrol sumber,adalah manajemen perubahan dokumen, program komputer, situs web yang besar, dan koleksi lainnya informasi.
Perubahan biasanya diidentifikasi oleh nomor atau huruf kode, disebut sebagai "nomor revisi", "tingkat revisi", atau hanya "revisi".
Sebagai contoh, sebuah set awal file adalah "revisi 1". Ketika perubahan pertama dibuat, set yang dihasilkan adalah "revisi 2", dan seterusnya.
Setiap revisi terkait dengan timestamp dan orang yang membuat perubahan. Revisi dapat dibandingkan, dipulihkan, dan dengan beberapa jenis file, bergabung.

Kebutuhan untuk cara yang logis untuk mengatur dan revisi kontrol telah ada selama hampir sepanjang menulis telah ada, tetapi kontrol revisi menjadi jauh lebih penting, dan rumit, ketika era komputasi dimulai.
Penomoran edisi buku dan revisi spesifikasi adalah contoh yang tanggal kembali ke era cetak saja. Saat ini, sistem kontrol revisi yang paling mampu (serta kompleks) adalah mereka yang digunakan dalam pengembangan perangkat lunak, di mana tim orang mungkin secara bersamaan melakukan perubahan ke file yang sama.
sistem kontrol versi (VCS) paling sering dijalankan sebagai aplikasi yang berdiri sendiri, tetapi kontrol revisi juga tertanam dalam berbagai jenis perangkat lunak seperti pengolah kata dan spreadsheet, web docs kolaboratif dan di berbagai sistem manajemen konten, misalnya, halaman Wikipedia sejarah.
kontrol revisi memungkinkan untuk kemampuan untuk kembali dokumen ke revisi sebelumnya, yang sangat penting untuk memungkinkan editor untuk melacak suntingan masing-masing, memperbaiki kesalahan, dan membela terhadap vandalisme dan spamming di wiki.

Gambaran
Dalam rekayasa perangkat lunak komputer, kontrol revisi adalah setiap jenis praktek yang trek dan memberikan kontrol atas perubahan kode sumber. Pengembang perangkat lunak kadang-kadang menggunakan software kontrol revisi untuk menjaga file dokumentasi dan konfigurasi serta kode sumber.
Seperti desain tim, mengembangkan dan software menyebarkan, itu adalah umum untuk beberapa versi dari perangkat lunak yang sama untuk digunakan di situs yang berbeda dan untuk pengembang perangkat lunak untuk dapat bekerja secara bersamaan pada update. Bug atau fitur dari perangkat lunak sering hanya hadir dalam versi tertentu (karena memperbaiki beberapa masalah dan pengenalan orang lain sebagai program berkembang). Oleh karena itu, untuk tujuan menemukan dan memperbaiki bug, itu sangat penting untuk dapat mengambil dan menjalankan versi yang berbeda dari perangkat lunak untuk menentukan di mana versi (s) masalah terjadi. Hal ini juga mungkin diperlukan untuk mengembangkan dua versi dari perangkat lunak bersamaan: misalnya, di mana satu versi telah bug tetap, tetapi tidak ada fitur baru (cabang), sedangkan versi lain adalah di mana fitur baru yang bekerja pada (trunk).
Pada tingkat yang paling sederhana, pengembang hanya bisa mempertahankan beberapa salinan dari versi yang berbeda dari program, dan label mereka secara tepat.

Struktur
kontrol revisi mengelola perubahan untuk satu set data dari waktu ke waktu. Perubahan ini dapat terstruktur dalam berbagai cara.
Seringkali data yang dianggap sebagai koleksi banyak item individu, seperti file atau dokumen, dan perubahan file individual dilacak. Ini perjanjian dengan intuisi tentang file terpisah tapi masalah penyebab ketika perubahan identitas, seperti selama penggantian nama, membelah atau penggabungan file. Dengan demikian, beberapa sistem seperti Git, bukan mempertimbangkan perubahan data secara keseluruhan, yang kurang intuitif untuk perubahan sederhana namun menyederhanakan perubahan yang lebih kompleks.
Ketika data yang berada di bawah kontrol revisi dimodifikasi, setelah diambil dengan memeriksa, ini bukan secara umum segera tercermin dalam sistem kontrol revisi (dalam repositori), tetapi harus bukannya diperiksa di atau berkomitmen. Salinan kontrol revisi luar dikenal sebagai "copy pekerjaan". Sebagai contoh sederhana, saat mengedit file komputer, data yang disimpan dalam memori dengan program editing adalah copy pekerjaan, yang dilakukan oleh tabungan. Konkretnya, satu mungkin mencetak dokumen, mengedit dengan tangan, dan hanya kemudian secara manual masukan perubahan ke dalam komputer dan simpan. Untuk kontrol kode sumber, copy pekerjaan adalah bukan salinan semua file dalam revisi tertentu, umumnya disimpan secara lokal pada komputer pengembang; [catatan 1] dalam hal ini menyimpan file hanya mengubah copy pekerjaan, dan memeriksa ke dalam repositori adalah langkah yang terpisah.
Jika beberapa orang yang bekerja pada satu set data tunggal atau dokumen, mereka secara implisit menciptakan cabang data (di copy pekerjaan mereka), dan dengan demikian masalah penggabungan timbul, seperti dibahas di bawah. Untuk mengedit dokumen kolaboratif sederhana, ini bisa dicegah dengan menggunakan penguncian file atau hanya menghindari bekerja pada dokumen yang sama bahwa orang lain bekerja pada.
sistem kontrol revisi sering terpusat, dengan toko tunggal otoritatif data, repositori, dan check-out dan check-in dilakukan dengan mengacu pada repositori pusat ini. Atau, di kontrol revisi didistribusikan, tidak ada repositori tunggal otoritatif, dan data dapat diperiksa dan diperiksa ke repositori apapun. Ketika memeriksa ke repositori yang berbeda, ini diartikan sebagai gabungan atau patch yang.

struktur grafik
grafik sejarah contoh proyek revisi dikendalikan; trunk adalah di hijau, cabang di kuning, dan grafik bukan pohon karena kehadiran gabungan (panah merah).
Dalam hal teori graph, revisi umumnya dianggap sebagai garis pembangunan (batang) dengan cabang off dari ini, membentuk sebuah pohon diarahkan, divisualisasikan sebagai satu atau lebih paralel garis pembangunan (the "mainlines" cabang) bercabang off batang. Pada kenyataannya struktur yang lebih rumit, membentuk grafik asiklik diarahkan, tetapi untuk banyak tujuan "pohon dengan gabungan" adalah sebuah pendekatan yang memadai.
Revisi terjadi secara berurutan dari waktu ke waktu, dan dengan demikian dapat diatur dalam urutan, baik dengan nomor revisi atau timestamp. [Catatan 2] revisi didasarkan pada revisi terakhir, meskipun mungkin untuk sebagian besar atau sepenuhnya menggantikan revisi sebelumnya, seperti "delete semua teks yang ada, insert teks baru". Dalam kasus yang paling sederhana, tanpa bercabang atau kehancuran, setiap revisi didasarkan pada pendahulunya terdekatnya saja, dan mereka membentuk garis sederhana, dengan versi terbaru tunggal, "HEAD" revisi atau tip. Dalam istilah teori graf, menggambar setiap revisi sebagai titik dan hubungan masing-masing "revisi berasal" sebagai panah (konvensional menunjuk dari tua ke yang lebih baru, dalam arah yang sama seperti waktu), ini adalah grafik linear. Jika ada percabangan, sehingga beberapa revisi masa depan didasarkan pada revisi terakhir, atau kehancuran, sehingga revisi dapat bergantung pada revisi lebih tua dari pendahulunya terdekatnya, maka grafik yang dihasilkan adalah bukan pohon diarahkan (setiap node dapat memiliki lebih dari satu anak), dan memiliki beberapa tips, sesuai dengan revisi tanpa anak-anak ( "revisi terbaru pada setiap cabang") [catatan 3] pada prinsipnya kebutuhan pohon yang dihasilkan tidak memiliki tip yang disukai ( "main" revisi terbaru) -. hanya berbagai berbeda revisi - tetapi dalam prakteknya satu tip umumnya diidentifikasi sebagai HEAD. Ketika revisi baru didasarkan pada HEAD, itu adalah baik diidentifikasi sebagai KEPALA baru, atau dianggap sebagai cabang baru. [Catatan 4] Daftar revisi dari awal sampai KEPALA (dalam hal teori grafik, jalan yang unik di pohon, yang membentuk grafik linear seperti sebelumnya) adalah batang atau arus utama. [catatan 5] Sebaliknya, ketika revisi dapat didasarkan pada lebih dari satu revisi sebelumnya (ketika sebuah node dapat memiliki lebih dari satu orang tua), proses yang dihasilkan disebut penggabungan, dan merupakan salah satu yang paling aspek kompleks kontrol revisi. Hal ini paling sering terjadi ketika perubahan terjadi pada beberapa cabang (paling sering dua, tapi kemungkinan lebih), yang kemudian digabung menjadi satu cabang menggabungkan kedua perubahan. Jika perubahan ini tumpang tindih, mungkin sulit atau tidak mungkin untuk menggabungkan, dan memerlukan intervensi manual atau menulis ulang.
Di hadapan gabungan, grafik yang dihasilkan tidak lagi pohon, sebagai node dapat memiliki beberapa orang tua, tetapi bukan berakar diarahkan asiklik grafik (DAG). grafik adalah asiklik karena orang tua selalu mundur dalam waktu, dan berakar karena ada adalah versi tertua. Namun, dengan asumsi bahwa ada batang, gabungan dari cabang dapat dianggap sebagai "eksternal" untuk pohon - perubahan di cabang dikemas sebagai patch, yang diterapkan ke HEAD (bagasi), membuat revisi baru tanpa secara eksplisit cabang, dan melestarikan struktur pohon. Jadi, sementara hubungan sebenarnya antara versi membentuk DAG, ini dapat dianggap sebagai pohon ditambah gabungan, dan batang itu sendiri adalah garis.
Dalam kontrol revisi didistribusikan, di hadapan beberapa repositori ini mungkin didasarkan pada versi aslinya tunggal (akar pohon).

strategi khusus
Teknik kontrol revisi dikembangkan dari proses formal berdasarkan pelacakan revisi cetak biru awal atau bluelines [rujukan?]. Sistem kontrol implisit diperbolehkan kembali ke keadaan sebelumnya dari desain, untuk kasus-kasus di mana sebuah rekayasa buntu dicapai dalam pengembangan desain. Sebuah meja revisi digunakan untuk melacak perubahan yang dilakukan. Selain itu, daerah modifikasi dari gambar yang disorot menggunakan awan revisi.

model sumber-manajemen
sistem kontrol revisi tradisional menggunakan model terpusat di mana semua fungsi kontrol revisi berlangsung pada server bersama. Jika dua pengembang mencoba untuk mengubah file yang sama pada waktu yang sama, tanpa beberapa metode pengelolaan akses pengembang mungkin berakhir Timpa pekerjaan masing-masing. sistem kontrol revisi terpusat memecahkan masalah ini dalam salah satu dari dua "model manajemen sumber" yang berbeda: mengunci file dan versi penggabungan.

operasi atom
Artikel utama: Atom komit
Operasi adalah atom jika sistem dibiarkan dalam keadaan konsisten bahkan jika operasi terganggu. Komit operasi biasanya yang paling penting dalam hal ini. Komit memberitahu sistem kontrol revisi untuk membuat sekelompok perubahan akhir, dan tersedia untuk semua pengguna. Tidak semua sistem kontrol revisi harus komit atom; terutama, CVS tidak memiliki fitur ini. [4]

mengunci file
Metode paling sederhana untuk mencegah "akses bersamaan" masalah melibatkan mengunci file sehingga hanya satu pengembang pada suatu waktu memiliki akses tulis ke pusat "repositori" salinan file-file. Setelah satu pengembang "cek out" file, orang lain dapat membaca file itu, tapi tidak ada orang lain bisa berubah file yang sampai pengembang bahwa "pemeriksaan dalam" versi update (atau membatalkan kasir).
File penguncian memiliki baik kelebihan dan kekurangan. Hal ini dapat memberikan beberapa perlindungan terhadap menggabungkan konflik sulit ketika pengguna membuat perubahan radikal ke banyak bagian dari file besar (atau kelompok file). Namun, jika file tersebut dibiarkan secara eksklusif terkunci terlalu lama, pengembang lain mungkin tergoda untuk bypass software kontrol revisi dan mengubah file secara lokal, sehingga menimbulkan masalah yang lebih serius.

versi penggabungan
Penggabungan dua file dapat menjadi operasi yang sangat halus, dan biasanya hanya mungkin jika struktur data sederhana, seperti dalam file teks. Hasil dari penggabungan dua file gambar mungkin tidak menghasilkan file gambar sama sekali. Pengembang kedua memeriksa dalam kode akan perlu untuk mengurus dengan penggabungan, untuk memastikan bahwa perubahan yang kompatibel dan bahwa operasi gabungan tidak memperkenalkan kesalahan logika sendiri dalam file. Masalah-masalah ini membatasi ketersediaan operasi gabungan otomatis atau semi-otomatis terutama untuk dokumen berbasis teks sederhana, kecuali plugin tertentu merge yang tersedia untuk jenis file.
Konsep mengedit dilindungi undang-undang dapat menyediakan sarana opsional secara eksplisit mengunci file untuk akses tulis eksklusif, bahkan ketika kemampuan penggabungan ada.

Baseline, label dan tag
Kebanyakan alat kontrol revisi akan menggunakan hanya satu dari istilah-istilah yang sama (baseline, label, tag) untuk merujuk pada tindakan mengidentifikasi snapshot ( "label proyek") atau catatan snapshot ( "mencobanya dengan dasar X") . Biasanya hanya salah satu syarat dasar, label, atau tag digunakan dalam dokumentasi atau diskusi [rujukan?]; mereka dapat sinonim dipertimbangkan.

kontrol revisi didistribusikan
Didistribusikan sistem kontrol revisi (DRCs) mengambil pendekatan peer-to-peer, yang bertentangan dengan pendekatan client-server sistem terpusat. Daripada, repositori pusat tunggal yang klien sinkronisasi, copy pekerjaan masing-masing peer dari basis kode adalah gudang bona-fide. [5] Didistribusikan etik kontrol revisi sinkronisasi dengan bertukar patch (perubahan-set) dari rekan rekan. Ini hasil dalam beberapa perbedaan penting dari sistem terpusat:

terminologi umum
Terminologi dapat bervariasi dari sistem ke sistem, tetapi beberapa istilah dalam penggunaan umum termasuk:

garis belakang
Disetujui revisi dari file dokumen atau sumber dari mana perubahan berikutnya dapat dibuat. Lihat baseline, label dan tag.

Cabang
Satu set file di bawah kontrol versi dapat bercabang atau bercabang pada titik waktu sehingga, dari waktu ke depan, dua salinan dari file-file dapat berkembang pada kecepatan yang berbeda atau dengan cara yang berbeda secara independen satu sama lain.

Perubahan
Perubahan (atau diff, atau delta) merupakan modifikasi khusus untuk dokumen dibawah kontrol versi. Granularity modifikasi dianggap perubahan bervariasi antara sistem kontrol versi.

Ubah daftar
Pada banyak sistem kontrol versi dengan komit atom multi-perubahan, daftar perubahan (atau CL), perubahan set, memperbarui, atau patch yang mengidentifikasi set perubahan yang dibuat dalam satu komit. Ini juga dapat mewakili pandangan berurutan dari kode sumber, memungkinkan pemeriksaan sumber "pada" setiap ID daftar perubahan tertentu.

Periksa
Untuk memeriksa (atau co) adalah untuk menciptakan sebuah copy pekerjaan lokal dari repositori. Seorang pengguna dapat menentukan revisi tertentu atau mendapatkan paket. Istilah 'checkout' juga dapat digunakan sebagai kata benda untuk menggambarkan copy pekerjaan. Ketika file telah check out dari file server bersama, itu tidak dapat diedit oleh pengguna lain. Anggap saja seperti sebuah hotel, ketika Anda check out, Anda tidak lagi memiliki akses ke fasilitas yang.

Klon
Kloning berarti menciptakan sebuah repositori yang berisi revisi dari repositori lain. Hal ini setara dengan mendorong atau menarik ke dalam repositori kosong (baru diinisialisasi). Sebagai kata benda, dua repositori dapat dikatakan klon jika mereka terus disinkronkan, dan berisi revisi yang sama.

Melakukan
Untuk melakukan (check-in, ci atau, lebih jarang, menginstal, mengirimkan atau merekam) adalah menulis atau menggabungkan perubahan yang dibuat di copy kembali bekerja ke repositori. Istilah 'melakukan' dan 'checkin' juga dapat digunakan sebagai kata benda untuk menggambarkan revisi baru yang dibuat sebagai hasil dari melakukan.

Konflik
Konflik terjadi ketika pihak yang berbeda membuat perubahan pada dokumen yang sama, dan sistem tidak dapat mendamaikan perubahan. Pengguna harus menyelesaikan konflik dengan menggabungkan perubahan, atau dengan memilih satu perubahan dalam mendukung yang lain.

kompresi delta
Kebanyakan perangkat lunak kontrol revisi menggunakan kompresi delta, yang mempertahankan hanya perbedaan antara versi-versi dari file. Hal ini memungkinkan untuk penyimpanan lebih efisien dari berbagai versi file.

aliran dinamis
Sebuah sungai di mana beberapa atau semua versi file adalah cermin dari versi aliran orangtua.

Ekspor
mengekspor adalah tindakan memperoleh file dari repositori. Hal ini mirip dengan memeriksa kecuali bahwa itu menciptakan pohon direktori bersih tanpa metadata versi-kontrol yang digunakan dalam copy pekerjaan. Hal ini sering digunakan sebelum penerbitan isi, misalnya.

Mengambil
Lihat tarik.

Integrasi kedepan
Proses penggabungan perubahan yang dibuat dalam batang utama menjadi pembangunan (fitur atau tim) cabang.

Kepala
Juga kadang-kadang disebut ujung, ini mengacu pada terbaru komit, baik untuk bagasi atau ke cabang. Batang dan setiap cabang memiliki kepala mereka sendiri, meskipun KEPALA kadang-kadang longgar digunakan untuk merujuk ke bagasi. [7]

Impor
mengimpor adalah tindakan menyalin pohon direktori lokal (yang saat ini tidak copy pekerjaan) ke dalam repositori untuk pertama kalinya.

Inisialisasi
untuk membuat yang baru, repositori kosong.

delta interleaved
beberapa perangkat lunak kontrol revisi menggunakan delta Interleaved, sebuah metode yang memungkinkan menyimpan sejarah file berbasis teks dalam cara yang lebih efisien daripada dengan menggunakan kompresi Delta.

Label
Lihat tag.

Garis utama
Mirip dengan batang, tetapi ada dapat menjadi arus utama untuk setiap cabang.

Menggabungkan
Sebuah penggabungan atau integrasi adalah operasi di mana dua set perubahan diterapkan ke file atau set file. Beberapa skenario sampel adalah sebagai berikut:
Seorang pengguna, bekerja pada sebuah set file, update atau sinkronisasi copy pekerjaan mereka dengan perubahan yang dibuat, dan diperiksa ke repositori, oleh pengguna lain. [8]
Seorang pengguna mencoba untuk check-in file yang telah diperbarui oleh orang lain karena file yang memeriksa, dan perangkat lunak kontrol revisi otomatis menggabungkan file (biasanya, setelah mendorong pengguna jika harus dilanjutkan dengan penggabungan otomatis, dan dalam beberapa kasus hanya melakukannya jika penggabungan dapat dengan jelas dan cukup diselesaikan).
Sebuah cabang dibuat, kode dalam file secara independen diedit, dan cabang diperbarui kemudian dimasukkan ke dalam satu, batang bersatu.
Sebuah set file bercabang, masalah yang ada sebelum percabangan adalah tetap dalam satu cabang, dan memperbaiki ini kemudian digabung ke dalam cabang lainnya. (Jenis penggabungan selektif kadang-kadang dikenal sebagai pick cherry untuk membedakannya dari penggabungan lengkap dalam kasus sebelumnya.)

Memajukan
Tindakan menyalin isi file dari lokasi yang kurang terkontrol ke lokasi yang lebih terkontrol. Sebagai contoh, dari ruang kerja pengguna ke dalam repositori, atau dari sungai ke induknya. [9]

Tarik dorong
Salin revisi dari satu

kontrol versi didistribusikan
Dalam pengembangan perangkat lunak, didistribusikan kontrol versi (juga dikenal sebagai kontrol revisi didistribusikan) adalah bentuk kontrol versi di mana basis kode yang lengkap, termasuk sejarah penuh, dicerminkan pada komputer setiap pengembang. [1] Hal ini memungkinkan manajemen otomatis bercabang dan penggabungan, mempercepat kebanyakan operasi (kecuali mendorong dan menarik), meningkatkan kemampuan untuk bekerja secara offline, dan tidak bergantung pada satu lokasi untuk backup. 
Pada tahun 2010, pengembangan perangkat lunak penulis Joel Spolsky dijelaskan didistribusikan sistem kontrol versi sebagai "mungkin kemajuan terbesar dalam teknologi pengembangan perangkat lunak dalam [masa] sepuluh tahun". [2]

Didistribusikan vs terpusat
sistem kontrol versi terdistribusi (DVCS) menggunakan pendekatan peer-to-peer untuk kontrol versi, yang bertentangan dengan pendekatan client-server sistem terpusat. kontrol revisi didistribusikan mensinkronisasikan repositori dengan mentransfer patch dari rekan rekan. Tidak ada versi pusat tunggal dari basis kode; sebagai gantinya, setiap pengguna memiliki salinan bekerja dan sejarah perubahan penuh.

Keuntungan dari DVCS (dibandingkan dengan sistem terpusat) meliputi:

Memungkinkan pengguna untuk bekerja secara produktif ketika tidak terhubung ke jaringan.
operasi umum (seperti komit, melihat sejarah, dan mengembalikan perubahan) yang lebih cepat untuk DVCS, karena tidak ada kebutuhan untuk berkomunikasi dengan server pusat. [5] Dengan DVCS, komunikasi hanya diperlukan ketika berbagi perubahan di antara rekan-rekan lainnya.
Memungkinkan pekerjaan swasta, sehingga pengguna dapat menggunakan perubahan mereka bahkan untuk draft awal mereka tidak ingin mempublikasikan. [Rujukan?]
salinan bekerja secara efektif berfungsi sebagai remote backup, yang menghindari mengandalkan satu mesin fisik sebagai titik tunggal kegagalan. [5]
Memungkinkan berbagai model pembangunan yang akan digunakan, seperti menggunakan cabang pengembangan atau model Komandan / Letnan. [Rujukan?]
Izin terpusat kontrol dari "versi release" dari proyek [rujukan?]
Pada proyek perangkat lunak FOSS itu jauh lebih mudah untuk membuat garpu proyek dari proyek yang terhenti karena konflik kepemimpinan atau ketidaksepakatan desain.
Kekurangan DVCS (dibandingkan dengan sistem terpusat) meliputi:

checkout awal dari repositori yang lebih lambat dibandingkan dengan checkout dalam sistem kontrol versi terpusat, karena semua cabang dan sejarah revisi akan disalin ke mesin lokal secara default.
Kurangnya mekanisme penguncian yang merupakan bagian dari yang paling terpusat VCS dan masih memainkan peran penting ketika datang ke non-Mergeable file biner seperti aset grafis atau file tunggal biner atau XML paket terlalu kompleks (misalnya dokumen kantor, file PowerBI, SQL Server Data Alat BI paket, dll.).
penyimpanan tambahan diperlukan untuk setiap pengguna memiliki salinan lengkap dari sejarah basis kode lengkap. 

Model kerja
model didistribusikan umumnya lebih cocok untuk proyek-proyek besar dengan pengembang sebagian independen, seperti proyek Linux kernel, karena pengembang dapat bekerja secara independen dan mengirimkan perubahan mereka untuk penggabungan (atau penolakan). Model ini didistribusikan secara fleksibel memungkinkan mengadopsi sumber kustom kontribusi kode alur kerja. Integrator alur kerja adalah yang paling banyak digunakan. Dalam model terpusat, pengembang harus cerita bersambung pekerjaan mereka, untuk menghindari masalah dengan versi yang berbeda.

repositori pusat dan cabang
Setiap proyek memiliki repositori pusat yang dianggap sebagai repositori resmi, yang dikelola oleh pengelola proyek. Pengembang mengkloning repositori ini untuk membuat salinan lokal identik dari basis kode. perubahan kode sumber di repositori pusat secara periodik disinkronkan dengan repositori lokal.
pengembang menciptakan cabang baru di repositori kode dan memodifikasi sumber lokal nya di cabang itu. Setelah pembangunan selesai, perubahan perlu diintegrasikan ke dalam repositori pusat.
permintaan tarik
Kontribusi ke repositori kode sumber yang menggunakan sistem kontrol versi terdistribusi biasanya dibuat dengan cara permintaan tarik, juga dikenal sebagai permintaan merge.Permintaan kontributor bahwa pengelola proyek menarik perubahan kode sumber, maka nama "tarik permintaan". pengelola harus menggabungkan permintaan tarik jika kontribusi harus menjadi bagian dari basis sumber.
Pengembang menciptakan permintaan tarik untuk memberitahu pengelola perubahan baru; thread komentar terkait dengan setiap permintaan tarik. Hal ini memungkinkan untuk diskusi terfokus perubahan kode. permintaan tarik disampaikan dapat dilihat oleh siapa dengan akses repositori. Permintaan tarik dapat diterima atau ditolak oleh pengelola.
Setelah permintaan tarik ditinjau dan disetujui, itu digabung ke dalam repositori. Tergantung pada alur kerja yang ditetapkan, kode mungkin perlu diuji sebelum dimasukkan ke dalam rilis resmi. Oleh karena itu, beberapa proyek mengandung cabang khusus untuk penggabungan permintaan tarik belum teruji.Proyek-proyek lain menjalankan suite tes otomatis pada setiap permintaan tarik, menggunakan alat integrasi berkesinambungan seperti Travis CI, dan cek resensi bahwa setiap kode baru memiliki cakupan uji yang tepat.

Git
Git (/ ɡɪt /)adalah sistem versi-kontrol terdistribusi untuk melacak perubahan kode sumber selama pengembangan perangkat lunak.Hal ini dirancang untuk mengkoordinasikan pekerjaan di antara programmer, tetapi dapat digunakan untuk melacak perubahan dalam setiap set file.
tujuannya termasuk kecepatan,integritas data,dan dukungan untuk didistribusikan, alur kerja non-linear.
penamaan

Git diciptakan oleh Linus Torvalds pada tahun 2005 untuk pengembangan kernel Linux, dengan pengembang kernel lainnya yang berkontribusi untuk pengembangan awal. Its pemelihara saat ini sejak tahun 2005 adalah Junio ​​Hamano. Seperti kebanyakan sistem kontrol versi lain yang didistribusikan, dan tidak seperti kebanyakan sistem client-server, setiap direktori Git pada setiap komputer adalah gudang penuh dengan sejarah lengkap dan versi pelacakan penuh kemampuan, independen dari akses jaringan atau server pusat. Git adalah perangkat lunak bebas dan open-source didistribusikan di bawah persyaratan Lisensi versi GNU General Public 2.

Rancangan
desain git terinspirasi oleh BitKeeper dan monoton.Git pada awalnya dirancang sebagai mesin sistem kontrol versi tingkat rendah, di atas yang lain bisa menulis ujung depan, seperti Cogito atau StGIT. [31] sejak proyek inti Git telah menjadi sistem kontrol versi lengkap yang dapat digunakan secara langsung.Sementara sangat dipengaruhi oleh BitKeeper, Torvalds sengaja dihindari pendekatan konvensional, yang mengarah ke desain yang unik.

karakteristik
desain Git adalah sintesis dari pengalaman Torvalds dengan Linux dalam menjaga proyek pembangunan terdistribusi besar, bersama dengan pengetahuan yang mendalam tentang kinerja sistem file yang diperoleh dari proyek yang sama dan kebutuhan mendesak untuk menghasilkan sistem yang bekerja dalam waktu singkat.

Struktur data
primitif Git adalah tidak inheren sistem manajemen source-code. Torvalds menjelaskan:

Dalam banyak hal Anda hanya bisa melihat git sebagai filesystem - itu konten-addressable, dan memiliki gagasan versioning, tapi aku benar-benar dirancang datang pada masalah dari sudut pandang orang filesystem (hey, kernel adalah apa yang saya lakukan) , dan saya benar-benar memiliki benar-benar nol kepentingan dalam menciptakan sistem SCM tradisional.
Dari pendekatan desain awal ini, Git telah mengembangkan set lengkap fitur yang diharapkan dari SCM tradisional, [32] dengan fitur sebagian besar diciptakan sesuai kebutuhan, kemudian disempurnakan dan diperluas dari waktu ke waktu.

Beberapa arus data dan tingkat penyimpanan dalam sistem kontrol revisi Git
Git memiliki dua struktur data: indeks bisa berubah (juga disebut panggung atau Cache) yang cache informasi tentang direktori kerja dan revisi berikutnya yang akan dilakukan; dan berubah, append-satunya objek database.

git GUI
Server git
Sebagai Git adalah sistem versi-kontrol terdistribusi, dapat digunakan sebagai server di luar kotak. Ini dikirimkan dengan built-in perintah git daemon yang dimulai TCP server sederhana yang berjalan pada protokol GIT. [63] Dedicated Git HTTP server bantuan (antara fitur-fitur lainnya) dengan menambahkan kontrol akses, menampilkan isi dari repositori Git melalui antarmuka web, dan mengelola beberapa repositori. Sudah repositori Git yang ada dapat dikloning dan berbagi untuk digunakan oleh orang lain sebagai repo terpusat. Hal ini juga dapat diakses melalui remote shell hanya dengan memiliki perangkat lunak Git diinstal dan memungkinkan pengguna untuk log in. [64] server Git biasanya mendengarkan pada TCP port 9418.

Server Git sebagai layanan
Ada banyak penawaran dari repositori Git sebagai layanan. Yang paling populer adalah GitHub, SourceForge, Bitbucket dan GitLab

ekstensi
Ada banyak ekstensi Git, seperti Git LFS, yang dimulai sebagai ekstensi untuk Git dalam komunitas GitHub dan sekarang banyak digunakan oleh repositori lainnya. Ekstensi biasanya secara independen dikembangkan dan dikelola oleh orang yang berbeda, tetapi di beberapa titik di masa depan ekstensi banyak digunakan dapat digabungkan ke Git.

Keamanan
Git tidak menyediakan mekanisme akses kontrol, tetapi dirancang untuk operasi dengan alat-alat lain yang mengkhususkan diri dalam kontrol akses. 
Pada tanggal 17 Desember 2014, mengeksploitasi ditemukan mempengaruhi Windows dan MacOS versi klien Git. Seorang penyerang bisa melakukan eksekusi kode sewenang-wenang pada komputer target dengan Git diinstal dengan membuat Git pohon berbahaya (direktori) bernama git (direktori di repositori Git yang menyimpan semua data dari repositori) dalam kasus yang berbeda (seperti git atau git, diperlukan karena Git tidak memungkinkan versi semua-huruf kecil dari git yang akan dibuat secara manual) dengan file berbahaya di git / kait subdirektori (folder dengan file executable yang Git berjalan) pada repositori bahwa penyerang dibuat atau pada repositori bahwa penyerang dapat memodifikasi.

Tentang Kontrol Versi
kontrol versi adalah sebuah sistem yang catatan perubahan ke file atau set file dari waktu ke waktu sehingga Anda dapat mengingat versi tertentu kemudian.
Untuk contoh dalam buku ini, Anda akan menggunakan kode sumber perangkat lunak file yang sedang versi dikendalikan, meskipun pada kenyataannya Anda dapat melakukan ini dengan hampir semua jenis file di komputer.
Jika Anda seorang grafis atau web desainer dan ingin menyimpan setiap versi dari gambar atau layout (yang Anda akan pasti ingin), Control System Versi (VCS) adalah hal yang sangat bijaksana untuk digunakan. Hal ini memungkinkan Anda untuk mengembalikan file yang dipilih kembali ke keadaan sebelumnya, revert seluruh kembali proyek ke keadaan sebelumnya, membandingkan perubahan dari waktu ke waktu, melihat siapa yang terakhir diubah sesuatu yang mungkin menyebabkan masalah, yang memperkenalkan masalah dan ketika, dan banyak lagi. Menggunakan VCS juga umumnya berarti bahwa jika Anda mengacaukan segalanya atau file kehilangan, Anda dapat dengan mudah pulih. Selain itu, Anda mendapatkan semua ini untuk overhead yang sangat kecil.

Sistem Kontrol Versi Lokal
yang sering digunakan adalah untuk menyalin file ke direktori lain . Pendekatan ini sangat umum karena sangat sederhana, tetapi juga sangat kesalahan rentan. Sangat mudah untuk lupa dimana direktori Anda berada di dan sengaja menulis ke file yang salah atau menyalin file Anda tidak bermaksud.

alat VCS populer adalah sistem yang disebut RCS, yang masih didistribusikan dengan banyak komputer. RCS bekerja dengan menjaga patch set (yaitu, perbedaan antara file) dalam format khusus pada disk; kemudian dapat menciptakan kembali apa yang file apapun tampak seperti pada setiap titik waktu dengan menambahkan semua patch.

Sistem Kontrol Versi terpusat
Permasalahan berikutnya yang dihadapi adalah bahwa mereka perlu berkolaborasi dengan pengembang pada sistem lainnya. Untuk mengatasi masalah ini, Terpusat Version Control Systems (CVCSs) dikembangkan. Sistem ini (seperti CVS, Subversion, dan Perforce) memiliki server tunggal yang berisi semua file yang berversi, dan sejumlah klien yang memeriksa file dari tempat pusat. Selama bertahun-tahun, ini telah menjadi standar untuk kontrol versi.
Pengaturan ini menawarkan banyak keuntungan, VCS terutama selama lokal. Sebagai contoh, semua orang tahu untuk tingkat tertentu apa yang orang lain pada proyek yang dilakukan. Administrator memiliki kontrol fine-grained atas siapa yang dapat melakukan apa, dan itu jauh lebih mudah untuk mengelola CVCS daripada itu adalah untuk berurusan dengan database lokal pada setiap klien.
Namun, konfigurasi ini juga memiliki beberapa kelemahan serius. Yang paling jelas adalah titik tunggal kegagalan bahwa server terpusat mewakili. Jika server yang turun selama satu jam, maka selama jam itu tidak ada yang bisa berkolaborasi atau menyimpan perubahan terhadap apa yang mereka kerjakan. Jika hard disk database pusat pada menjadi rusak, dan backup yang tepat belum disimpan, anda akan kehilangan setiap - seluruh sejarah dari proyek kecuali snapshot orang kebetulan punya pada mesin lokal mereka.

Sistem Kontrol Versi Terdistribusi
Di sinilah Distributed Version Control Systems (DVCSs) langkah dalam sebuah DVCS (seperti Git, Mercurial, Bazaar atau Darcs), klien tidak hanya memeriksa snapshot terbaru dari file.; bukan, mereka penuh dari repositori tersebut, termasuk sejarah penuh. Dengan demikian, jika ada mati Server, dan sistem ini berkolaborasi melalui server itu, salah satu repositori klien dapat disalin kembali ke server untuk mengembalikannya. Setiap klon benar-benar full backup dari semua data
Untuk menangani masalah ini, para programmer mengembangkan berbagai VCS lokal yang memiliki database sederhana untuk menyimpan semua perubahan pada file di bawah kontrol revisi.

Selain itu, banyak dari sistem ini berurusan dengan cukup baik dengan memiliki beberapa repositori jauh mereka dapat bekerja dengan, sehingga Anda dapat berkolaborasi dengan kelompok-kelompok orang yang berbeda dengan cara yang berbeda secara bersamaan dalam proyek yang sama. Hal ini memungkinkan Anda untuk mengatur beberapa jenis alur kerja yang tidak mungkin dalam sistem terpusat, seperti model hierarkis.

Instalasi Git
Sebelum Anda mulai menggunakan Git, Anda harus membuatnya tersedia di komputer Anda. Bahkan jika itu sudah terpasang, itu mungkin ide yang baik untuk update ke versi terbaru. Anda juga dapat menginstal sebagai sebuah paket atau melalui installer lain, atau download source code dan kompilasi sendiri.

Catatan
Git versi 2.8.0. Meskipun sebagian besar perintah yang kita gunakan harus bekerja bahkan dalam versi kuno Git, beberapa dari mereka tidak mungkin atau mungkin bertindak sedikit berbeda jika Anda menggunakan versi lama. Sejak Git cukup baik untuk melestarikan kompatibilitas mundur, versi setelah 2,8 harus bekerja dengan baik.

Instalasi di Linux
Jika Anda ingin memasang alat dasar Git di Linux menggunakan installer biner, biasanya Anda dapat melakukannya melalui alat manajemen paket yang datang dengan distribusi Anda. Jika Anda berada di Fedora (atau berbasis RPM distribusi erat-terkait, seperti RHEL atau CentOS), Anda dapat menggunakan DNF:

$ Sudo DNF install git-semua
Jika Anda pada distribusi berbasis Debian, seperti Ubuntu, coba apt:

$ Sudo apt install git-semua
Untuk lebih banyak pilihan, ada petunjuk untuk menginstal pada beberapa distribusi Unix yang berbeda di situs Git, di https://git-scm.com/download/linux.

Instalasi di MacOS
Ada beberapa cara untuk menginstal Git pada Mac. Yang paling mudah mungkin untuk menginstal Xcode Command Line Tools. Pada Mavericks (10,9) atau di atas Anda dapat melakukannya hanya dengan mencoba untuk menjalankan git dari Terminal pertama kalinya.

$ Git --version
Jika Anda tidak memiliki itu sudah terpasang, ia akan meminta Anda untuk menginstalnya.
Jika Anda ingin lebih up to date versi, Anda juga dapat menginstalnya melalui installer biner.

Anda juga dapat menginstal sebagai bagian dari GitHub untuk MacOS menginstal. Alat GUI Git mereka memiliki opsi untuk menginstal alat baris perintah juga. Anda dapat men-download alat yang dari GitHub untuk MacOS website, di https://desktop.github.com.

Instalasi pada Windows
Ada juga beberapa cara untuk menginstal Git pada Windows. Yang paling resmi membangun tersedia untuk di-download di situs Git. Hanya pergi ke https://git-scm.com/download/win dan download akan dimulai secara otomatis. Catatan bahwa ini adalah sebuah proyek yang disebut Git untuk Windows, yang terpisah dari Git itu sendiri; untuk informasi lebih lanjut tentang hal itu, pergi ke https://gitforwindows.org.

Untuk mendapatkan instalasi otomatis paket Git Cokelat. 
Lain cara mudah untuk mendapatkan Git diinstal adalah dengan menginstal GitHub Desktop. installer meliputi versi baris perintah dari Git serta GUI. Hal ini juga bekerja dengan baik dengan PowerShell, dan set up caching credential yang solid dan pengaturan CRLF waras. Kita akan belajar lebih banyak tentang hal-hal kecil kemudian, tetapi cukup untuk mengatakan mereka hal-hal yang Anda inginkan. Anda dapat men-download dari situs GitHub Desktop.

Instalasi dari Sumber
Jika Anda ingin menginstal Git dari sumber, Anda harus memiliki library yang dibutuhkan oleh Git: autotools, curl, zlib, openssl, expat, dan libiconv. Misalnya, jika Anda berada di sistem yang memiliki DNF (seperti Fedora) atau apt-get (seperti sistem berbasis Debian), Anda dapat menggunakan salah satu dari perintah ini untuk menginstal dependensi minimal untuk kompilasi dan instalasi Git binari:

$ Sudo DNF install dh-autoreconf ikal-devel expat-devel gettext-devel \
  openssl-devel perl-devel zlib-devel
$ Sudo apt-get install dh-autoreconf libcurl4-GnuTLS-dev libexpat1-dev \
  gettext libz-dev libssl-dev
Agar dapat menambahkan dokumentasi dalam berbagai format (doc, html, info), dependensi tambahan yang diperlukan:

$ Sudo DNF install asciidoc xmlto docbook2X
$ Sudo apt-get install asciidoc xmlto docbook2x
Catatan
Pengguna RHEL dan RHEL-derivatif seperti CentOS dan Scientific Linux harus mengaktifkan repositori EPEL untuk men-download paket docbook2X.

Pengaturan akun dan Konfigurasi
GitHub adalah tuan rumah tunggal terbesar untuk repositori Git, dan merupakan titik pusat kolaborasi untuk jutaan pengembang dan proyek. Sebagian besar dari semua repositori Git-host pada GitHub, dan banyak proyek open-source menggunakannya untuk Git hosting, pelacakan masalah, kode, dan hal-hal lain. Jadi sementara itu bukan bagian langsung dari Git proyek open source, ada kesempatan baik bahwa Anda akan ingin atau perlu berinteraksi dengan GitHub di beberapa titik saat menggunakan Git secara profesional.

Jika Anda tidak tertarik menggunakan GitHub untuk menjadi tuan rumah proyek Anda sendiri atau untuk berkolaborasi dengan proyek-proyek lain yang di-host di GitHub, Anda dapat dengan aman skip to Git Tools.

Jika Anda menggunakan distribusi berbasis Debian (Debian / Ubuntu / Ubuntu-derivatif), Anda juga perlu paket instalasi-info:

$ Sudo apt-get install install-info
Jika Anda menggunakan distribusi berbasis RPM (Fedora / RHEL / RHEL-derivatif), Anda juga perlu paket getopt (yang sudah diinstal pada distro berbasis Debian):

$ Sudo DNF install getopt
Selain itu, jika Anda menggunakan Fedora / RHEL / RHEL-derivatif, Anda perlu melakukan ini

$ Sudo ln -s / usr / bin / db2x_docbook2texi / usr / bin / docbook2x-texi
karena untuk perbedaan nama biner.

Bila Anda memiliki semua dependensi yang diperlukan, Anda dapat pergi ke depan dan ambil terbaru tagged rilis tarball dari beberapa tempat. Anda bisa mendapatkannya melalui situs kernel.org, di https://www.kernel.org/pub/software/scm/git, atau cermin di situs GitHub, di https://github.com/git/git rilis /. Ini umumnya sedikit lebih jelas apa yang versi terbaru adalah pada halaman GitHub, tetapi halaman kernel.org juga memiliki tanda tangan rilis jika Anda ingin memverifikasi download.
Kemudian, mengkompilasi dan menginstal:

$ Tar -zxf git-2.8.0.tar.gz
$ Cd git-2.8.0
$ Make configure
$ ./Configure --prefix = / usr
$ Membuat semua info doc
$ Sudo make install install-doc install-html install-info
Setelah ini dilakukan, Anda juga bisa mendapatkan Git melalui Git sendiri untuk update:

$ Git clone git: //git.kernel.org/pub/scm/git/git.git

Pengaturan akun dan Konfigurasi
Hal pertama yang perlu Anda lakukan adalah membuat account pengguna bebas. Cukup kunjungi https://github.com, memilih nama pengguna yang belum diambil, berikan alamat email dan password, dan klik hijau besar “Mendaftar untuk GitHub” tombol.

The GitHub sign-up bentuk.
GitHub akan mengirimkan email untuk memverifikasi alamat yang Anda berikan.

Catatan
GitHub menyediakan hampir semua fungsi dengan akun gratis, kecuali beberapa fitur canggih. Selain itu, repositori swasta terbatas pada 3 kolaborator.
rencana dibayar GitHub termasuk alat canggih dan fitur serta peningkatan batas untuk layanan gratis. 

Mengklik logo Octocat di bagian atas-kiri layar akan membawa Anda ke halaman dashboard Anda. Anda sekarang siap untuk menggunakan GitHub.

SSH Access
Sampai sekarang, Anda sepenuhnya dapat terhubung dengan Git repositori menggunakan https: // protokol, otentikasi dengan username dan password Anda hanya mengatur. Namun, untuk proyek-proyek hanya clone publik, Anda bahkan tidak perlu mendaftar - akun yang baru kita buat datang ke dalam bermain ketika kita garpu proyek dan push to garpu kami sedikit kemudian.

Jika Anda ingin menggunakan SSH remote, Anda harus mengkonfigurasi kunci publik. (Jika Anda tidak sudah memiliki satu, lihat Membangkitkan Anda SSH Public Key.) Buka pengaturan akun Anda menggunakan link di bagian kanan atas jendela:
Setelan akun 
Kemudian pilih “kunci SSH” bagian di sepanjang sisi kiri.

kunci SSH.
klik "Add kunci SSH" tombol, memberikan kunci Anda nama, paste isi Anda ~ / .ssh / id_rsa.pub (atau apa pun yang Anda menamakannya) berkas kunci publik ke dalam area teks, dan klik “Tambah kunci”.

Catatan
Pastikan untuk nama Anda kunci SSH sesuatu yang Anda ingat. Anda dapat nama masing-masing tombol Anda (misalnya "Laptop saya" atau "Account Kerja") sehingga jika Anda perlu untuk mencabut kunci kemudian, Anda dapat dengan mudah mengatakan mana yang Anda cari.

Avatarmu
Anda dapat mengganti avatar yang dihasilkan untuk Anda dengan gambar yang Anda pilih. Pertama pergi ke tab “Profil” (di atas tab SSH Keys) dan klik “Upload foto baru”.

Profil
Kami akan memilih salinan logo Git yang ada di hard drive kami dan kemudian kami mendapatkan kesempatan untuk tanaman itu.

Tanaman avatar Anda upload.
Sekarang di mana saja Anda berinteraksi di situs, orang akan melihat avatar Anda di samping nama pengguna.

Jika Anda kebetulan telah meng-upload avatar ke layanan Gravatar populer (sering digunakan untuk account Wordpress), avatar yang akan digunakan secara default dan Anda tidak perlu melakukan langkah ini.

Alamat Email Anda
Cara GitHub peta komit Git Anda kepada pengguna Anda berdasarkan alamat email. Jika Anda menggunakan beberapa alamat email di komit Anda dan Anda ingin GitHub untuk menghubungkan mereka dengan benar, Anda perlu menambahkan semua alamat email yang Anda telah digunakan untuk bagian Email dari bagian admin.

Tambahkan semua alamat email Anda.
Dalam alamat email Tambah kita dapat melihat beberapa negara yang berbeda yang mungkin. Alamat atas diverifikasi dan ditetapkan sebagai alamat utama, yang berarti bahwa adalah di mana Anda akan mendapatkan pemberitahuan dan penerimaan. Alamat kedua diverifikasi dan sehingga dapat ditetapkan sebagai primer jika Anda ingin beralih mereka. Alamat akhir adalah diverifikasi, yang berarti bahwa Anda tidak dapat membuat alamat utama Anda. Jika GitHub melihat semua ini pada pesan komit dalam repositori di situs, itu akan dihubungkan ke pengguna Anda sekarang.

Dua Faktor Otentikasi
Akhirnya, untuk keamanan ekstra, Anda pasti harus menyiapkan dua faktor Otentikasi atau “2FA”. Dua faktor otentikasi adalah mekanisme otentikasi yang menjadi lebih dan lebih populer baru-baru ini untuk mengurangi risiko akun anda terganggu jika password Anda dicuri entah bagaimana. Menyalakannya akan membuat GitHub meminta dua metode yang berbeda dari otentikasi, sehingga jika salah satu dari mereka terganggu, penyerang tidak akan dapat mengakses akun Anda.

Anda dapat menemukan dua faktor otentikasi setup di bawah tab Keamanan Setelan akun Anda.

2FA di Tab Security
Jika Anda klik pada “Set up otentikasi dua faktor” tombol, ia akan membawa Anda ke halaman konfigurasi di mana Anda dapat memilih untuk menggunakan aplikasi telepon untuk menghasilkan kode sekunder Anda ( “waktu berdasarkan satu kali password”), atau Anda dapat memiliki GitHub mengirimkan kode melalui SMS setiap kali Anda harus login.

Setelah Anda memilih metode mana yang Anda suka dan ikuti petunjuk untuk menyiapkan 2FA, akun Anda maka akan sedikit lebih aman dan Anda akan harus menyediakan

Membuat repositori baru
Anda dapat membuat repositori baru di akun pribadi atau organisasi apapun di mana Anda memiliki izin yang memadai.

Tip: Pemilik dapat membatasi hak akses penciptaan repositori dalam sebuah organisasi.

Di sudut kanan atas halaman manapun, menggunakan menu drop-down, dan pilih repositori New.

Drop-down dengan pilihan untuk membuat repositori baru
Opsional, untuk membuat repositori dengan struktur direktori dan file dari repositori yang ada, gunakan Pilih drop-down Template dan pilih repositori Template. Anda akan melihat repositori template yang dimiliki oleh Anda dan organisasi Anda seorang anggota atau bahwa Anda telah digunakan sebelumnya.

Template menu drop-down
Gunakan menu drop-down Pemilik, dan pilih akun yang ingin memiliki repositori.

Pemilik menu drop-down
Ketik nama untuk repositori Anda, dan deskripsi opsional.

Menciptakan lapangan repositori
Pilih visbility repositori. Untuk informasi lebih lanjut, lihat "Tentang visibilitas repositori."

tombol radio untuk memilih visibilitas repositori
Jika Anda tidak menggunakan template, ada sejumlah item opsional Anda dapat pre-mengisi repositori Anda dengan. Jika Anda mengimpor repositori yang ada untuk GitHub, tidak memilih salah satu dari pilihan ini, karena Anda dapat memperkenalkan gabungan konflik. Anda dapat menambahkan atau membuat file baru menggunakan antarmuka pengguna atau memilih untuk menambahkan file baru menggunakan baris perintah nanti. Untuk informasi lebih lanjut, lihat "Mengimpor repositori Git menggunakan baris perintah," "Menambahkan file ke repositori menggunakan baris perintah," dan "Mengatasi menggabungkan konflik."

Anda dapat membuat README, yang merupakan dokumen yang menjelaskan proyek Anda. Untuk informasi lebih lanjut, lihat "Tentang READMEs."
Anda dapat membuat file gitignore, yang merupakan satu set mengabaikan aturan. Untuk informasi lebih lanjut, lihat "Mengabaikan file."
Anda dapat memilih untuk menambahkan lisensi perangkat lunak untuk proyek Anda. Untuk informasi lebih lanjut, lihat "Perizinan repositori."
Opsional, jika rekening pribadi atau organisasi di mana Anda membuat penggunaan setiap GitHub Apps dari GitHub Marketplace, pilih semua aplikasi yang ingin Anda gunakan dalam repositori.

Daftar akun Anda GitHub Apps dari GitHub Marketplace dan pilihan untuk akses hibah
Klik Buat repositori.

Di bagian bawah halaman Quick Setup yang dihasilkan, di bawah "Impor kode dari repositori tua", Anda dapat memilih untuk mengimpor proyek untuk repositori baru Anda. Untuk melakukannya, klik kode Impor.